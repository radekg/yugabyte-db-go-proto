// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.17.3
// source: yb/consensus/consensus.proto

package api

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ConsensusServiceClient is the client API for ConsensusService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConsensusServiceClient interface {
	// Analogous to AppendEntries in Raft, but only used for followers.
	UpdateConsensus(ctx context.Context, in *ConsensusRequestPB, opts ...grpc.CallOption) (*ConsensusResponsePB, error)
	// Similar to UpdateConsensus but takes a batch of ConsensusRequestPB
	// and returns a batch of ConsensusResponsePB.
	MultiRaftUpdateConsensus(ctx context.Context, in *MultiRaftConsensusRequestPB, opts ...grpc.CallOption) (*MultiRaftConsensusResponsePB, error)
	// RequestVote() from Raft.
	RequestConsensusVote(ctx context.Context, in *VoteRequestPB, opts ...grpc.CallOption) (*VoteResponsePB, error)
	// Implements all of the one-by-one config change operations, including
	// AddServer() and RemoveServer() from the Raft specification, as well as
	// an operation to change the role of a server between VOTER and PRE_VOTER.
	// An OK response means the operation was successful.
	ChangeConfig(ctx context.Context, in *ChangeConfigRequestPB, opts ...grpc.CallOption) (*ChangeConfigResponsePB, error)
	GetNodeInstance(ctx context.Context, in *GetNodeInstanceRequestPB, opts ...grpc.CallOption) (*GetNodeInstanceResponsePB, error)
	// Force this node to run a leader election.
	RunLeaderElection(ctx context.Context, in *RunLeaderElectionRequestPB, opts ...grpc.CallOption) (*RunLeaderElectionResponsePB, error)
	// Notify originator about lost election, so it could reset its timeout.
	LeaderElectionLost(ctx context.Context, in *LeaderElectionLostRequestPB, opts ...grpc.CallOption) (*LeaderElectionLostResponsePB, error)
	// Force this node to step down as leader.
	LeaderStepDown(ctx context.Context, in *LeaderStepDownRequestPB, opts ...grpc.CallOption) (*LeaderStepDownResponsePB, error)
	// Get the latest committed or received opid on the server.
	GetLastOpId(ctx context.Context, in *GetLastOpIdRequestPB, opts ...grpc.CallOption) (*GetLastOpIdResponsePB, error)
	// Returns the committed Consensus state.
	GetConsensusState(ctx context.Context, in *GetConsensusStateRequestPB, opts ...grpc.CallOption) (*GetConsensusStateResponsePB, error)
	// Instruct this server to remotely bootstrap a tablet from another host.
	StartRemoteBootstrap(ctx context.Context, in *StartRemoteBootstrapRequestPB, opts ...grpc.CallOption) (*StartRemoteBootstrapResponsePB, error)
}

type consensusServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConsensusServiceClient(cc grpc.ClientConnInterface) ConsensusServiceClient {
	return &consensusServiceClient{cc}
}

func (c *consensusServiceClient) UpdateConsensus(ctx context.Context, in *ConsensusRequestPB, opts ...grpc.CallOption) (*ConsensusResponsePB, error) {
	out := new(ConsensusResponsePB)
	err := c.cc.Invoke(ctx, "/yb.consensus.ConsensusService/UpdateConsensus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consensusServiceClient) MultiRaftUpdateConsensus(ctx context.Context, in *MultiRaftConsensusRequestPB, opts ...grpc.CallOption) (*MultiRaftConsensusResponsePB, error) {
	out := new(MultiRaftConsensusResponsePB)
	err := c.cc.Invoke(ctx, "/yb.consensus.ConsensusService/MultiRaftUpdateConsensus", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consensusServiceClient) RequestConsensusVote(ctx context.Context, in *VoteRequestPB, opts ...grpc.CallOption) (*VoteResponsePB, error) {
	out := new(VoteResponsePB)
	err := c.cc.Invoke(ctx, "/yb.consensus.ConsensusService/RequestConsensusVote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consensusServiceClient) ChangeConfig(ctx context.Context, in *ChangeConfigRequestPB, opts ...grpc.CallOption) (*ChangeConfigResponsePB, error) {
	out := new(ChangeConfigResponsePB)
	err := c.cc.Invoke(ctx, "/yb.consensus.ConsensusService/ChangeConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consensusServiceClient) GetNodeInstance(ctx context.Context, in *GetNodeInstanceRequestPB, opts ...grpc.CallOption) (*GetNodeInstanceResponsePB, error) {
	out := new(GetNodeInstanceResponsePB)
	err := c.cc.Invoke(ctx, "/yb.consensus.ConsensusService/GetNodeInstance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consensusServiceClient) RunLeaderElection(ctx context.Context, in *RunLeaderElectionRequestPB, opts ...grpc.CallOption) (*RunLeaderElectionResponsePB, error) {
	out := new(RunLeaderElectionResponsePB)
	err := c.cc.Invoke(ctx, "/yb.consensus.ConsensusService/RunLeaderElection", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consensusServiceClient) LeaderElectionLost(ctx context.Context, in *LeaderElectionLostRequestPB, opts ...grpc.CallOption) (*LeaderElectionLostResponsePB, error) {
	out := new(LeaderElectionLostResponsePB)
	err := c.cc.Invoke(ctx, "/yb.consensus.ConsensusService/LeaderElectionLost", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consensusServiceClient) LeaderStepDown(ctx context.Context, in *LeaderStepDownRequestPB, opts ...grpc.CallOption) (*LeaderStepDownResponsePB, error) {
	out := new(LeaderStepDownResponsePB)
	err := c.cc.Invoke(ctx, "/yb.consensus.ConsensusService/LeaderStepDown", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consensusServiceClient) GetLastOpId(ctx context.Context, in *GetLastOpIdRequestPB, opts ...grpc.CallOption) (*GetLastOpIdResponsePB, error) {
	out := new(GetLastOpIdResponsePB)
	err := c.cc.Invoke(ctx, "/yb.consensus.ConsensusService/GetLastOpId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consensusServiceClient) GetConsensusState(ctx context.Context, in *GetConsensusStateRequestPB, opts ...grpc.CallOption) (*GetConsensusStateResponsePB, error) {
	out := new(GetConsensusStateResponsePB)
	err := c.cc.Invoke(ctx, "/yb.consensus.ConsensusService/GetConsensusState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consensusServiceClient) StartRemoteBootstrap(ctx context.Context, in *StartRemoteBootstrapRequestPB, opts ...grpc.CallOption) (*StartRemoteBootstrapResponsePB, error) {
	out := new(StartRemoteBootstrapResponsePB)
	err := c.cc.Invoke(ctx, "/yb.consensus.ConsensusService/StartRemoteBootstrap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConsensusServiceServer is the server API for ConsensusService service.
// All implementations should embed UnimplementedConsensusServiceServer
// for forward compatibility
type ConsensusServiceServer interface {
	// Analogous to AppendEntries in Raft, but only used for followers.
	UpdateConsensus(context.Context, *ConsensusRequestPB) (*ConsensusResponsePB, error)
	// Similar to UpdateConsensus but takes a batch of ConsensusRequestPB
	// and returns a batch of ConsensusResponsePB.
	MultiRaftUpdateConsensus(context.Context, *MultiRaftConsensusRequestPB) (*MultiRaftConsensusResponsePB, error)
	// RequestVote() from Raft.
	RequestConsensusVote(context.Context, *VoteRequestPB) (*VoteResponsePB, error)
	// Implements all of the one-by-one config change operations, including
	// AddServer() and RemoveServer() from the Raft specification, as well as
	// an operation to change the role of a server between VOTER and PRE_VOTER.
	// An OK response means the operation was successful.
	ChangeConfig(context.Context, *ChangeConfigRequestPB) (*ChangeConfigResponsePB, error)
	GetNodeInstance(context.Context, *GetNodeInstanceRequestPB) (*GetNodeInstanceResponsePB, error)
	// Force this node to run a leader election.
	RunLeaderElection(context.Context, *RunLeaderElectionRequestPB) (*RunLeaderElectionResponsePB, error)
	// Notify originator about lost election, so it could reset its timeout.
	LeaderElectionLost(context.Context, *LeaderElectionLostRequestPB) (*LeaderElectionLostResponsePB, error)
	// Force this node to step down as leader.
	LeaderStepDown(context.Context, *LeaderStepDownRequestPB) (*LeaderStepDownResponsePB, error)
	// Get the latest committed or received opid on the server.
	GetLastOpId(context.Context, *GetLastOpIdRequestPB) (*GetLastOpIdResponsePB, error)
	// Returns the committed Consensus state.
	GetConsensusState(context.Context, *GetConsensusStateRequestPB) (*GetConsensusStateResponsePB, error)
	// Instruct this server to remotely bootstrap a tablet from another host.
	StartRemoteBootstrap(context.Context, *StartRemoteBootstrapRequestPB) (*StartRemoteBootstrapResponsePB, error)
}

// UnimplementedConsensusServiceServer should be embedded to have forward compatible implementations.
type UnimplementedConsensusServiceServer struct {
}

func (UnimplementedConsensusServiceServer) UpdateConsensus(context.Context, *ConsensusRequestPB) (*ConsensusResponsePB, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateConsensus not implemented")
}
func (UnimplementedConsensusServiceServer) MultiRaftUpdateConsensus(context.Context, *MultiRaftConsensusRequestPB) (*MultiRaftConsensusResponsePB, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MultiRaftUpdateConsensus not implemented")
}
func (UnimplementedConsensusServiceServer) RequestConsensusVote(context.Context, *VoteRequestPB) (*VoteResponsePB, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestConsensusVote not implemented")
}
func (UnimplementedConsensusServiceServer) ChangeConfig(context.Context, *ChangeConfigRequestPB) (*ChangeConfigResponsePB, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeConfig not implemented")
}
func (UnimplementedConsensusServiceServer) GetNodeInstance(context.Context, *GetNodeInstanceRequestPB) (*GetNodeInstanceResponsePB, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNodeInstance not implemented")
}
func (UnimplementedConsensusServiceServer) RunLeaderElection(context.Context, *RunLeaderElectionRequestPB) (*RunLeaderElectionResponsePB, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunLeaderElection not implemented")
}
func (UnimplementedConsensusServiceServer) LeaderElectionLost(context.Context, *LeaderElectionLostRequestPB) (*LeaderElectionLostResponsePB, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaderElectionLost not implemented")
}
func (UnimplementedConsensusServiceServer) LeaderStepDown(context.Context, *LeaderStepDownRequestPB) (*LeaderStepDownResponsePB, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaderStepDown not implemented")
}
func (UnimplementedConsensusServiceServer) GetLastOpId(context.Context, *GetLastOpIdRequestPB) (*GetLastOpIdResponsePB, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLastOpId not implemented")
}
func (UnimplementedConsensusServiceServer) GetConsensusState(context.Context, *GetConsensusStateRequestPB) (*GetConsensusStateResponsePB, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsensusState not implemented")
}
func (UnimplementedConsensusServiceServer) StartRemoteBootstrap(context.Context, *StartRemoteBootstrapRequestPB) (*StartRemoteBootstrapResponsePB, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartRemoteBootstrap not implemented")
}

// UnsafeConsensusServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConsensusServiceServer will
// result in compilation errors.
type UnsafeConsensusServiceServer interface {
	mustEmbedUnimplementedConsensusServiceServer()
}

func RegisterConsensusServiceServer(s grpc.ServiceRegistrar, srv ConsensusServiceServer) {
	s.RegisterService(&ConsensusService_ServiceDesc, srv)
}

func _ConsensusService_UpdateConsensus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConsensusRequestPB)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsensusServiceServer).UpdateConsensus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yb.consensus.ConsensusService/UpdateConsensus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsensusServiceServer).UpdateConsensus(ctx, req.(*ConsensusRequestPB))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsensusService_MultiRaftUpdateConsensus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MultiRaftConsensusRequestPB)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsensusServiceServer).MultiRaftUpdateConsensus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yb.consensus.ConsensusService/MultiRaftUpdateConsensus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsensusServiceServer).MultiRaftUpdateConsensus(ctx, req.(*MultiRaftConsensusRequestPB))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsensusService_RequestConsensusVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VoteRequestPB)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsensusServiceServer).RequestConsensusVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yb.consensus.ConsensusService/RequestConsensusVote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsensusServiceServer).RequestConsensusVote(ctx, req.(*VoteRequestPB))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsensusService_ChangeConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeConfigRequestPB)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsensusServiceServer).ChangeConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yb.consensus.ConsensusService/ChangeConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsensusServiceServer).ChangeConfig(ctx, req.(*ChangeConfigRequestPB))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsensusService_GetNodeInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeInstanceRequestPB)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsensusServiceServer).GetNodeInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yb.consensus.ConsensusService/GetNodeInstance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsensusServiceServer).GetNodeInstance(ctx, req.(*GetNodeInstanceRequestPB))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsensusService_RunLeaderElection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RunLeaderElectionRequestPB)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsensusServiceServer).RunLeaderElection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yb.consensus.ConsensusService/RunLeaderElection",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsensusServiceServer).RunLeaderElection(ctx, req.(*RunLeaderElectionRequestPB))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsensusService_LeaderElectionLost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaderElectionLostRequestPB)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsensusServiceServer).LeaderElectionLost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yb.consensus.ConsensusService/LeaderElectionLost",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsensusServiceServer).LeaderElectionLost(ctx, req.(*LeaderElectionLostRequestPB))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsensusService_LeaderStepDown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaderStepDownRequestPB)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsensusServiceServer).LeaderStepDown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yb.consensus.ConsensusService/LeaderStepDown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsensusServiceServer).LeaderStepDown(ctx, req.(*LeaderStepDownRequestPB))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsensusService_GetLastOpId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLastOpIdRequestPB)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsensusServiceServer).GetLastOpId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yb.consensus.ConsensusService/GetLastOpId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsensusServiceServer).GetLastOpId(ctx, req.(*GetLastOpIdRequestPB))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsensusService_GetConsensusState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsensusStateRequestPB)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsensusServiceServer).GetConsensusState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yb.consensus.ConsensusService/GetConsensusState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsensusServiceServer).GetConsensusState(ctx, req.(*GetConsensusStateRequestPB))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsensusService_StartRemoteBootstrap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartRemoteBootstrapRequestPB)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsensusServiceServer).StartRemoteBootstrap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/yb.consensus.ConsensusService/StartRemoteBootstrap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsensusServiceServer).StartRemoteBootstrap(ctx, req.(*StartRemoteBootstrapRequestPB))
	}
	return interceptor(ctx, in, info, handler)
}

// ConsensusService_ServiceDesc is the grpc.ServiceDesc for ConsensusService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConsensusService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "yb.consensus.ConsensusService",
	HandlerType: (*ConsensusServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UpdateConsensus",
			Handler:    _ConsensusService_UpdateConsensus_Handler,
		},
		{
			MethodName: "MultiRaftUpdateConsensus",
			Handler:    _ConsensusService_MultiRaftUpdateConsensus_Handler,
		},
		{
			MethodName: "RequestConsensusVote",
			Handler:    _ConsensusService_RequestConsensusVote_Handler,
		},
		{
			MethodName: "ChangeConfig",
			Handler:    _ConsensusService_ChangeConfig_Handler,
		},
		{
			MethodName: "GetNodeInstance",
			Handler:    _ConsensusService_GetNodeInstance_Handler,
		},
		{
			MethodName: "RunLeaderElection",
			Handler:    _ConsensusService_RunLeaderElection_Handler,
		},
		{
			MethodName: "LeaderElectionLost",
			Handler:    _ConsensusService_LeaderElectionLost_Handler,
		},
		{
			MethodName: "LeaderStepDown",
			Handler:    _ConsensusService_LeaderStepDown_Handler,
		},
		{
			MethodName: "GetLastOpId",
			Handler:    _ConsensusService_GetLastOpId_Handler,
		},
		{
			MethodName: "GetConsensusState",
			Handler:    _ConsensusService_GetConsensusState_Handler,
		},
		{
			MethodName: "StartRemoteBootstrap",
			Handler:    _ConsensusService_StartRemoteBootstrap_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "yb/consensus/consensus.proto",
}
